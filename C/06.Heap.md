## 06.Heap
------

### 1. 堆定义

**(二叉)堆**是一个数组，它可以被看成一个近似的完全二叉树。

因此，给定一个结点的下标`i`，可以很容易计算得到它的父结点、左孩子和右孩子的下标：

 - 父结点：`PARENT(i) = floor(i/2)`
 - 左孩子：`LEFT(i) = 2i`
 - 右孩子：`RIGHT(i) = 2i + 1`
 
 下面是一个大顶堆的例子：
 
 <img src = "https://img-blog.csdnimg.cn/2019091210010921.png" width = "60%">
 
 其数组表示如下图所示：
 
 <img src = "https://img-blog.csdnimg.cn/20190912100341609.png" width = "50%">
 
 **大顶堆的性质**是指除了根结点以外的所有结点`i`都要满足：`A[PARENT(i)] ≥ A[i]`
 
 关于堆有如下值得注意的几点：
 
**注1**：堆并不保证所有元素有序。<br>
**注2**：堆除了最后一层其他层都是**完全**的。<br>
**注2**：堆中的元素时**按层的顺序存储**的，在后面会看到这种顺序存储的好处。<br>
**注3**：定义堆中结点的**高度**为该结点到叶结点最长简单路径上**边**的数目，进而把堆的高度定义为根结点的高度。

**叶子结点**：由于堆是一棵完全二叉树，因此堆的叶子结点只可能出现在最后两层中，如上图中的`2、4、1、9、3`。

值得注意的一点是，堆的最后一个非叶子结点的下标为`floor(length/2)`，这个性质在后面建堆的过程中很有用。

### 2. 维护堆的性质

大顶堆的最重要的性质是：堆中的任何非根结点都要满足`A[PARENT(i)] ≥ A[i]`，因此维护堆的性质的过程主要就是使得某个结点要大于其孩子结点。

```c
void MAX_HEAPIFY(ElemType* A, int length, int i) {
	int l = LEFT(i);
	int r = RIGHT(i);
	ElemType largest = i;
	if (l <= length && A[l] > A[largest])
		largest = l;

	if (r <= length && A[r] > A[largest])
		largest = r;

	if (largest != i) {
		SWAP(A[i], A[largest]);
		MAX_HEAPIFY(A, length, largest);
	}	
}
```
上述代码确保了结点`i`的大小大于其孩子结点的大小，使得结点`i`满足了大顶堆的要求，然后通过递归的方式来保持其子树中的结点也满足大顶堆的要求。

下面是一个例子，当`i = 2`时：

<img src = "https://img-blog.csdnimg.cn/20190912110840627.png" width = "100%">

此时，显然结点`A[2] = 4`违反了大顶堆的性质，需要将`4`和`14`进行交换。交换之后，`A[4] = 4`仍然违反了大顶堆的性质，因此需要再次将`4`和`8`交换，完成结点`A[2]`的性质的维护。

### 3. 建堆

建堆的过程很简单，只需要从下往上对所有的非叶子结点调用`MAX_HEAPIFY`来维护堆的性质，对所有的非叶子结点迭代完之后，大顶堆就建立完毕了。

```c
void BUILD_MAX_HEAP(A, length) {
	for (int i = length / 2; i > 0; --i) {
		MAX_HEAPIFY(A, length, i);
	}
}
```

值得注意的是，这里用到了前面提到的性质：**堆的最后一个非叶子结点的下标为`floor(length/2)`。**

查看：[源码](./src/06.Heap.c)|[C版本](../C/06.Heap.md)|[Python版本](../Python/06.Heap.md)
