## 01.Linked_List
------

### 1. 单链表定义

单链表的结构如下图所示：

<img src = "https://img-blog.csdnimg.cn/2019090210052474.png" width = "60%">

其中，第一个结点为**头结点**，头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。

定义单链表的结点如下：

```c
typedef struct Node {
	ElemType data;
	struct Node* next;
}Node, * LinkedList;
```

其中，`data`为结点数据域，`ElemType`为数据域的类型，`next`为指针域，用于存储下一个结点的地址。

### 2. 链表初始化

单链表在初始时只有一个头结点，因此单链表初始化的过程需要创建一个头结点：

```c
Status LinkedList_Init(LinkedList* L) {
	// 链表初始化
	*L = (LinkedList)malloc(sizeof(Node));
	if (!(*L)) return ERROR;
	else {
		(*L)->next = NULL;
	}
	return OK;
}
```
其中，通过`malloc`申请了一段大小为`sizeof(Node)`的内存作为头结点，然后用`L`指向这段内存。

声明并初始化一个单链表的过程如下：

```c
LinkedList L;
LinkedList_Init(&L);
```
### 3. 链表基本操作

1. 遍历
```c
typedef void (*callback)(ElemType);
void LinkedList_Traverse(LinkedList L, callback func)
{
	if (L == NULL) return ERROR;
	Node * p = L->next;
	while (p) {
		func(p->data);
		p = p->next;
	}
	printf("\n");
}
```
其中，func为一个函数指针，作为访问某个结点的函数。例如：
```c
void print(ElemType data) {
	printf("%d ", data);
}

LinkedList_Traverse(L, print);
```
上述遍历过程为打印出每个结点的`data`的值。

2. 链表尾部插入数据
```c
Status LinkedList_Push_back(LinkedList L, ElemType data) {
	// 在链表最后面插入一个结点
	if (L == NULL) return ERROR;
	Node * p = L;
	while (p->next)
		p = p->next;
	Node * newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) return ERROR;
	else {
		newNode->data = data;
		newNode->next = NULL;
		p->next = newNode;
	}
	return OK;
}
```
3. 链表头部插入数据
```c
Status LinkedList_Push_front(LinkedList L, ElemType data) {
	// 在链表最前面插入一个结点
	if (L == NULL) return ERROR;
	Node * p = L;
	Node * newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) return ERROR;
	else {
		newNode->next = L->next;
		newNode->data = data;
		L->next = newNode;
	}
	return OK;
}
```
4. 指定位置插入数据
```c
Status LinkedList_Insert(LinkedList L, int i, ElemType data) {
	// 在位置i处插入一个结点
	if (L == NULL) return ERROR;
	Node * p = L;
	if (i < 0) return ERROR;	// i < 0
	for (int j = 0; j < i; ++j) {
		if (p->next == NULL) return ERROR; // i > length
		else p = p->next;
	}
	Node* newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) return ERROR;
	else {
		newNode->next = p->next;
		newNode->data = data;
		p->next = newNode;
	}
	return OK;
}
```
5. 指定位置删除数据
```c
Status LinkedList_Delete(LinkedList L, int i) {
	if (L == NULL) return ERROR;
	Node * p = L;
	if (i < 0) return ERROR;
	for (int j = 0; j < i; ++j) {
		if (p->next == NULL) return ERROR;
		else p = p->next;
	}
	if (p->next == NULL) return ERROR;
	Node * q = p->next;
	p->next = p->next->next;
	free(q);
	p = NULL;
	return OK;
}
```
### 4. 链表其它操作
1. 链表反转

```c
Status LinkedList_Reverse(LinkedList L) {
	// 三指针法
	if (L == NULL) return ERROR;	// 链表未初始化
	if (L->next == NULL || L->next->next == NULL) return OK;	// 链表为空或者只有一个结点无需反转
	Node * prev = L->next, *cur = L->next->next, *nex = L->next->next->next;
	prev->next = NULL;	// 第一个结点的next置空
	while (nex != NULL)	// 如果下一个结点不为空
	{
		cur->next = prev;
		prev = cur; cur = nex; nex = nex->next;
	}
	cur->next = prev;
	L->next = cur;
	return OK;
}
```
其中，`L == NULL`表示链表未初始化，`L->next == NULL || L->next->next == NULL`表示链表元素少于两个，便无需翻转。

`prev->next`表示将第一个结点的`next`置空。


2. 链表的中间结点
```c
Node* LinkedList_Mid(LinkedList L)
{
	if (L == NULL) return NULL;
	Node * fast = L, *slow = L;
	while (fast != NULL && fast->next != NULL) {
		fast = fast->next->next;
		slow = slow->next;
	}
	return slow;
}
```
3. 倒数第k个结点
```c
Node* LinkedList_KToEnd(LinkedList L, int k)
{
	if (L == NULL) return NULL;
	Node * fast = L, *slow = L;
	while (k-- && fast != NULL) {
		fast = fast->next;
	}
	while (fast != NULL) {
		fast = fast->next;
		slow = slow->next;
	}
	return slow;
}
```
4. 冒泡排序
```c
Status LinkedList_BubbleSort(LinkedList L)
{
	if (L == NULL) return ERROR;
	Node * p = L, *q = L->next, *r = NULL;
	while (r != L->next) {
		while (q->next != NULL && q->next != r) {
			if (q->data < q->next->data) {	// 小于，指针后移
				p = q;
				q = q->next;
			}
			else {	// 大于，交换
				p->next = q->next;
				q->next = q->next->next;
				p->next->next = q;
				p = p->next;
			}
		}
		r = q;
		p = L;
		q = L->next;
	}
	return OK;
}
```
5. 有序链表合并
```c
void LinkedList_Merge(LinkedList L1, LinkedList L2)
{
	// 将L2合并到L1上
	if (L1 == NULL || L2 == NULL) return ERROR;
	Node * pa = L1->next, *pb = L2->next, *p = L1;
	while (pa && pb)
	{
		if (pa->data < pb->data) {
			p->next = pa; p = pa; pa = pa->next;
		}
		else {
			p->next = pb; p = pb; pb = pb->next;
		}
	}
	p->next = pa ? pa : pb;
	free(L2);
}
```
