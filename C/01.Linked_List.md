## 01.Linked_List
------

### 1. 单链表定义

单链表的结构如下图所示：

<img src = "https://img-blog.csdnimg.cn/2019090210052474.png" width = "60%">

其中，第一个结点为**头结点**，头结点的数据域可以不存储任何信息，也可以存储如线性表的长度等附加信息，头结点的指针域存储指向第一个结点的指针。

定义单链表的结点如下：

```c
typedef struct Node {
	ElemType data;
	struct Node* next;
}Node, * LinkedList;
```

其中，`data`为结点数据域，`ElemType`为数据域的类型，`next`为指针域，用于存储下一个结点的地址。

### 2. 链表初始化

单链表在初始时只有一个头结点，因此单链表初始化的过程需要创建一个头结点：

```c
Status LinkedList_Init(LinkedList* L) {
	// 链表初始化
	*L = (LinkedList)malloc(sizeof(Node));
	if (!(*L)) return ERROR;
	else {
		(*L)->next = NULL;
	}
	return OK;
}
```
其中，通过`malloc`申请了一段大小为`sizeof(Node)`的内存作为头结点，然后用`L`指向这段内存。

声明并初始化一个单链表的过程如下：

```c
LinkedList L;
LinkedList_Init(&L);
```
### 3. 链表基本操作

1. 遍历
```c
typedef void (*callback)(ElemType);
void LinkedList_Traverse(LinkedList L, callback func)
{
	if (L == NULL) return ERROR;
	Node * p = L->next;
	while (p) {
		func(p->data);
		p = p->next;
	}
	printf("\n");
}
```
其中，func为一个函数指针，作为访问某个结点的函数。例如：
```c
void print(ElemType data) {
	printf("%d ", data);
}

LinkedList_Traverse(L, print);
```
上述遍历过程为打印出每个结点的`data`的值。

2. 链表尾部插入数据
```c
Status LinkedList_Push_back(LinkedList L, ElemType data) {
	// 在链表最后面插入一个结点
	if (L == NULL) return ERROR;
	Node * p = L;
	while (p->next)
		p = p->next;
	Node * newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) return ERROR;
	else {
		newNode->data = data;
		newNode->next = NULL;
		p->next = newNode;
	}
	return OK;
}
```
3. 链表头部插入数据
```c
Status LinkedList_Push_front(LinkedList L, ElemType data) {
	// 在链表最前面插入一个结点
	if (L == NULL) return ERROR;
	Node * p = L;
	Node * newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) return ERROR;
	else {
		newNode->next = L->next;
		newNode->data = data;
		L->next = newNode;
	}
	return OK;
}
```
4. 指定位置插入数据
```
Status LinkedList_Insert(LinkedList L, int i, ElemType data) {
	// 在位置i处插入一个结点
	if (L == NULL) return ERROR;
	Node * p = L;
	if (i < 0) return ERROR;	// i < 0
	for (int j = 0; j < i; ++j) {
		if (p->next == NULL) return ERROR; // i > length
		else p = p->next;
	}
	Node* newNode = (Node*)malloc(sizeof(Node));
	if (!newNode) return ERROR;
	else {
		newNode->next = p->next;
		newNode->data = data;
		p->next = newNode;
	}
	return OK;
}
```

