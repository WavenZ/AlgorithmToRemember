## 14. 二分查找

-----

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用**顺序存储结构**，而且表中元素按关键字**有序排列**。

### 1. 不含重复元素的二分查找

对于通常情况下的二分查找，我们还默认线性表中不包含重复元素，如`1 2 3 4 6 7 8 9`。

此时，使用经典的二分查找即可：
```c
template<class T>
int binary_search(const std::vector<T>& vec, const T& val) {
	int low = 0, high = vec.size() - 1;
	while (low <= high) {	// divide and conquer
		int mid = low + (high - low) / 2;	// avoid overflow
		if (val == vec[mid])
			return mid;	// success
		else if (val < vec[mid])
			high = mid - 1;
		else
			low = mid + 1;
	}
	return -1;	// fail
}
```
其中，值得注意的有两点：

**1.mid = low + (high - low) / 2**<br>
这里采用上述的形式而不是采用`mid = (low + high) / 2`的原因是当`low`和`high`的值比较大时，其值可能溢出。此外，另一种与`mid = low + (high - low) / 2`等价的写法为：`mid = low + ((high - low) >> 1)`。

**2.while(low <= high)**<br>
当`low == high`时，`mid = low + (high - low) / 2 = low`为最后一个元素。那么这个元素是否值得检查呢？
答案是显然的，由于上述循环中更改范围边界时使用的是`high = mid - 1`和`low = mid + 1`，因此之前被检查过的值都位于`[low, high]`范围之外。当最后只剩一个元素`mid == high == low`时检查是必须的。

### 1. 含重复元素的二分查找

当要查找的线性表中包含重复元素时，如`{1, 2, 3, 4, 5, 6, 6, 6, 6, 6, 7, 8, 9}`。

如果使用前面实现的`binary_search`来查找值`6`，则得到的实际上是第4个`6`。这种情况下函数返回的元素的下标实际上并没有太大的意义，通常的做法是返回一个`bool`值，表示是否查找成功。

