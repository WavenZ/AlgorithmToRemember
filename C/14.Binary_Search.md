## 14. 二分查找

-----

二分查找也称折半查找（Binary Search），它是一种效率较高的查找方法。但是，折半查找要求线性表必须采用**顺序存储结构**，而且表中元素按关键字**有序排列**。

### 1. 不含重复元素的二分查找

对于通常情况下的二分查找，我们还默认线性表中不包含重复元素，如`1 2 3 4 6 7 8 9`。

此时，使用经典的二分查找即可：
```c
template<class T>
int binary_search(const std::vector<T>& vec, const T& val) {
	int low = 0, high = vec.size() - 1;
	while (low <= high) {	// divide and conquer
		int mid = low + (high - low) / 2;	// avoid overflow
		if (val == vec[mid])
			return mid;	// success
		else if (val < vec[mid])
			high = mid - 1;
		else
			low = mid + 1;
	}
	return -1;	// fail
}
```
其中，值得注意的有两点：

**1.mid = low + (high - low) / 2**<br>
这里采用上述的形式而不是采用`mid = (low + high) / 2`的原因是当`low`和`high`的值比较大时，其值可能溢出。此外，另一种与`mid = low + (high - low) / 2`等价的写法为：`mid = low + ((high - low) >> 1)`。

**2.while(low <= high)**<br>
当`low == high`时，`mid = low + (high - low) / 2 = low`为最后一个元素。那么这个元素是否值得检查呢？
答案是显然的，由于上述循环中更改范围边界时使用的是`high = mid - 1`和`low = mid + 1`，因此之前被检查过的值都位于`[low, high]`范围之外。当最后只剩一个元素`mid == high == low`时检查是必须的。

### 2. 含重复元素的二分查找

当要查找的线性表中包含重复元素时，如`{1, 2, 3, 4, 5, 6, 6, 6, 6, 6, 7, 8, 9}`。

如果使用前面实现的`binary_search`来查找值`6`，则得到的实际上是第4个`6`。这种情况下函数返回的元素的下标实际上并没有太大的意义，通常的做法是返回一个`bool`值，表示是否查找成功。

一般地，当线性表中存在重复元素时，我们往往希望查找的是某个值`val`第一次出现的位置。例如在上面查找元素`6`，则应返回下标`5`。

C++的STL库中有算法关于二分查找的函数，它们正是用于上述情况：

`bool binary_search(args)`：在有序线性表中二分查找某个元素是否存在，存在则返回true。<br>
`pos upper_bound(args)`：在有序线性表中二分查找第一个**大于**某个元素的下标，查找到返回下标。<br>
`pos low_bound(args)`：在有序线性表中二分查找第一个**大于等于**某个元素的下标，查找到则返回下标。<br>

例如，在有序表`{1, 2, 3, 4, 4, 4, 5, 6, 7, 8}`中查找元素`4`时，`lower_bound`和`upper_bound`的区别如下：

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20190919102135440.png" width = "60%">
<div align = left>
	
可以看到，`lower_bound`和`upper_bound`分别可以看作`[begin, +∞)`和`(begin, +∞)`。

那么如何实现上述两个函数呢？

#### 2.1 lower_bound

`lower_bound`是查找第一个**大于等于**值`val`的元素的位置。

值得注意的有两点。第一点是查找的是**大于等于**，而不是等于，因此在二分查找时，如果满足`vec[mid] >= val`，则不能像经典的二分查找那样用`high = mid - 1`将`vec[mid]`排除在查找区间范围外，因为`vec[mid]`可能就是第一个大于等于`val`的值。

因此，当`vec[mid] > val`时，二分查找的上界的变化应为`high = mid`。

第二点是要查找满足条件的**第一个**值，因此循环在满足条件时不能立即结束，而是继续循环直到`low = high`时结束，因为由第一点得到`high`会一直指向一个满足条件的值，而`low`会一直向`high`逼近。

因此，循环结束的条件应为`while(low < high)`。

将前面的程序进行简单的修改可以得到`lower_bound`的一个实现：

```c
template<class T>
int lower_bound(const std::vector<T>& vec, const T& val) {
	int low = 0, high = vec.size();
	while (low < high) {
		int mid = low + (high - low) / 2;
		if (vec[mid] < val)
			low = mid + 1;
		else high = mid;
	}
	return high;
}
```

可以看到，这个程序与前面的`binary_search`的差别有四点：
 - 循环结束条件由`while(low <= high)`变为`while(low < high)`，原因前面已经解释过。
 - 去掉了`if(vec[mid] == val) return mid`条件分支，原因是显然的，不过多解释。
 - 将`else high = mid - 1`变为`else high = mid`，原因上面也已经解释过了。
 - 函数返回值由`return -1`变为`return high`，由于`vec[high]`是始终满足大于等于`val`的元素值，因此循环结束时，`high`指向第一个大于等于`val`的元素。（当不存在大于等于`val`的元素时，返回的`high`是初始化的`vec.size()`的值，即最后一个元素的后一个值。）



