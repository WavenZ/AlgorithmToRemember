## 13. 红黑树
---

### 1. 红黑树的性质
红黑树是一棵**二叉搜索树**，它在每个结点上增加了一个存储位来表示结点的**颜色**（BLACK或RED）。通过对任何一条从根到叶子的简单路径上各个结点的颜色进行约束，红黑树可确保没有一条路径会比其他路径长2倍，因此红黑树近似为一棵**平衡二叉搜索树**。

**红黑树**满足下列5条性质：

 1. 每个结点为红色或者黑色。
 2. 根节点为黑色。
 3. 每个叶结点都是黑色。
 4. **红色结点的子结点必为黑色**。
 5. **对于每个结点，从该结点到其后代所有叶结点的简单路径上，均包含相同数量的黑色结点**。
 
 **注1**：其中前三条性质比较容易维护，而后两条性质在插入或者删除的时候很容易被破坏。<br>
 **注2**：红黑树中的叶结点指的是NIL结点，而不是普通树中定义的叶结点，如下图。
 
 <div align = center>
<img src="https://img-blog.csdnimg.cn/20190406214851458.png" width="25%" ><br>
(绘制红黑树的图时通常会省略NIL结点)
 
 <div align = left>
 
 
一棵典型的红色树如下图所示：
<div align = center>
<img src="https://img-blog.csdnimg.cn/20190406213639723.png" width="80%" >
 <div align = left>
 
 可以看到，红黑树不仅要满足上面提及的几条性质之外，还需要满足**二叉搜索树**的性质：
 1. 若任意结点的左子树不为空，则左子树上所有结点的值均小于其根节点上的值。
 2. 若任意结点的右子树不为空，则右子树上所有结点的值均大于其根节点上的值。
 3. 任意结点的左右子树也称为二叉搜索树。
 4. 二叉搜索树中没有关键字相同的结点。

此外，一棵红色树的高度满足：

<img src = "https://img-blog.csdnimg.cn/20190915100834973.png" width = "90%">

其中，`n`为红黑树内部结点的个数。由该性质可得，搜索、插入、删除等操作可在`O(lg n)`时间内完成。

### 2. 红黑树的平衡

当我们向红黑树中**插入**或者**删除**结点时，通常会不可避免的破坏红黑树的性质。因此，我们通常采取一些措施来维护被破坏的性质，常用的操作是**变色**和**旋转**。

**1. 变色操作**

下面来看看变色操作是如何维护红黑树的性质。

首先，回顾**红黑树的性质：**

 1. 每个结点为红色或者黑色。
 2. **根节点为黑色**。
 3. 每个叶结点都是黑色。
 4. **红色结点的子结点必为黑色**。
 5. 对于每个结点，从该结点到其后代所有叶结点的简单路径上，均包含相同数量的黑色结点。

其中，第四条性质在插入或者删除结点的时候最容易被破坏。

为了维护**性质5**，插入的新结点一律设置为**红色**结点，因此当插入的结点的父结点也为红色时便破坏了性质4，如下图：

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20190915113405608.png" width = "80%">
<div align = left>
 
 因此，为了维护红黑树的性质，将插入的结点的父结点以及叔父结点**变色**为黑色，并将其祖父结点**变色**为红色。由于祖父结点变为了红色，可能会违反红黑树的性质，因此需要递归进行维护操作。
 
 此外，**变色**操作还灵活的应用在其他地方，如插入空树时应直接将结点变为黑色（性质2）。

**2. 旋转操作**

**红黑树的旋转**实际上和**AVL旋转**(见[AVL树](11.AVL_Tree.md))是一样的，如下图：

<div align = center>
<img src = "https://img-blog.csdnimg.cn/20190915102030952.png" width = "80%">
<div align = left>

**AVL旋转**的目的很明确：在不改变结点的前驱后继的基础上，使结点由非平衡状态变为平衡状态。

**红黑树**由于不存在平衡因子这个特性，因此**红黑旋转**的目的不是为了改善平衡性，而是和**变色**操作一样为了维护红黑树的五条性质。

下面从**红黑旋转**能改变什么特点这一视角来探讨其在维护红黑树性质方面的作用。

从上图中可以看出，**红黑旋转**有如下几个特点：
 - 1. 红黑旋转不改变结点的**前驱后继**关系。
 - 2. 红黑旋转可能改变根节点的左右子树的**黑高**。(性质5)
 
前面说到，当插入结点的父结点和叔父结点都是红色结点时，可以通过**递归变色**来维护红黑树的性质。

如果**父结点为红色、叔父结点为黑色**时，仅利用变色会破坏性质5（对于每个结点，从该结点到其后代所有叶结点的简单路径上，均包含相同数量的黑色结点）。

如下图：

<div align = center>
<img src = "https://img-blog.csdnimg.cn/2019091515182662.png" width = "80%"> 
<div align = left>
 
 上图中，仅利用**变色操作**改变了左右子树的黑高，而**红黑旋转**的作用也能改变左右子树的黑高，此时再用**右旋**操作即可使得左右子树的黑高平衡恢复原样。
 
 上述简要介绍了**变色**和**旋转**是如何影响红黑树的性质的，下面会详细讨论红黑树在**插入**和**删除**时如何利用**变色+旋转**来维护红黑树的性质，并分析为什么**红黑树的插入删除比AVL树更加高效**。
 
 ### 3. 红黑树插入
 
 **时间复杂度：O(lgn)**
 
 **红黑树的插入**和**AVL树的插入**类似，都是先将结点插入树中，然后采取相应的措施来维护红黑树/AVL树的性质。不同的是，AVL在维护其平衡性质时仅有旋转操作，而红黑树既有旋转操作还有变色操作。
 
 首先说明一点：**红黑树在插入结点时默认先将其着为红色。**（这里先不解释，推迟到总结时说明）
 
 那么再次回顾红黑树的性质：
 
 1. 每个结点为红色或者黑色。
 2. **根节点为黑色**。
 3. 每个叶结点都是黑色。
 4. **红色结点的子结点必为黑色**。
 5. 对于每个结点，从该结点到其后代所有叶结点的简单路径上，均包含相同数量的黑色结点。
 
 可以看到，在插入新结点的时候，可能违反**性质2**和**性质4**.
 
 关于**性质2**，只需要将其**变色**为黑色即可。
 
 关于**性质4**的维护，需要分两种情况讨论，这两种情况实际上在讨论**红黑树的平衡**时已经熟悉过了，下面详细地进行讨论。
 
 **情况一：父结点和叔父结点都为红色**
 
 <div align = center>
 <img src = "https://img-blog.csdnimg.cn/20190915154319716.png" width = "60%">
 <div align = left>
 
 前面已经提到，此时只需要递归进行**变色**即可，如下图：
 
 <div align = center>
 <img src = "https://img-blog.csdnimg.cn/20190915154740277.png" width = "50%">
 <div align = left>
 
值得注意的是，由于**变色**后该子树的根节点变为了红色，因此可能仍违反性质4，此时需要将维护操作向上递归，直到不再违反红黑树的性质。

（也许有人会想，如果一直到根节点都仍是违反性质4，那怎么办？实际上如果是根节点则直接可以着色为黑色，因为根节点直接变为黑色不会破坏**性质5**，而其他结点直接变为黑色会影响该结点所在子树的黑高。）

 **情况二：父结点为红色、叔父结点为黑色**
 
 <div align = center>
 <img src = "https://img-blog.csdnimg.cn/20190915160147174.png" width = "60%">
 <div align = left>

此时，可以按照插入结点的位置和其父结点的位置分为`LL`、`LR`、`RL`、`RR`四种情况。

熟悉**AVL树**的人会发现这正是AVL树在插入时分析的四种情况，对于`LL`和`RR`只需要一次旋转即可达到平衡状态，而`LR`和`RL`则需要进行两次**AVL旋转**才能达到平衡状态。

在**红黑树**的插入中，处理的基本步骤和**AVL**插入相同，都是需要将`LR`**左旋**转换成`LL`，将`RL`**右旋**转换成`RR`，然后再次利用相应的旋转操作使得达到平衡态。不同的是，红黑树的在处理时还需要进行**变色操作**。

下面以`LL`和`LR`为例说明，`RR`和`RL`是相应的镜像情况。

 <div align = center>
 <img src = "https://img-blog.csdnimg.cn/20190915161610597.png" width = "60%">
 <div align = left>
  
 上图是`LL型`的处理方法，首先将父结点以及祖父结点反色，然后进行**右旋**达到平衡态。可以看到，处理前后祖父节点的左右子树的黑高未发生变化，且祖父结点仍为黑色，因此处理完成，无需继续向上传递。
 
 下图是`LR型`的处理方法，首先对左子树进行**左旋**将其转换为`LL型`，然后执行`LL型`的处理步骤即可。
 
 <div align = center>
 <img src = "https://img-blog.csdnimg.cn/20190915162707135.png" width = "60%">
 <div align = left>
