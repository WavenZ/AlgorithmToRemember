## 11. AVL Tree
---

### 1. 平衡二叉树

BST(Binary Search Tree，二叉搜索树)，是一种简单的查找树，它的特点如下：

 - 若任意结点的左子树不为空，则左子树上所有结点的值均小于其根节点上的值。
 - 若任意结点的右子树不为空，则右子树上所有结点的值均大于其根节点上的值。
 - 任意结点的左右子树也称为二叉搜索树。
 - 二叉搜索树中没有关键字相同的结点。
 
 按照**二叉搜索树**的插入规则，当插入数据时，会发生如下情况：
 
 <img src = "https://img-blog.csdnimg.cn/20190913140516438.png" width = "80%">
 
 从图中可以看出，当插入数据为有序序列时，二叉搜索树会退化为一个链表，此时插入和查找等操作时间复杂度为`Θ(n)`。
 
 为了改进这个问题，G. M. **A**delson-**V**elsky和E. M. **L**andis提出了一种高度平衡的查找树结构，简称**AVL树**。
 
 **AVL树需要满足以下几个要求：**
 
  - AVL树满足二叉搜索树的所有特点
  - AVL树的每个结点的左右子树的高度之差的绝对值（**平衡因子**）最多为1。
  
  为了满足上述要求，需要在二叉搜索树的基础上增加一个操作：**平衡**。
  
  此外，为了判断AVL树的平衡性，为每个节点添加了一个`bf`域作为平衡因子，AVL树的节点定义如下：
  
  ```c
typedef struct Node {
	ElemType data;
	int bf;
	struct Node* lchild, * rchild;
}Node, *AVLTree;
  ```
  其中，平衡因子的取值为如下三个值：
  
  ```c
#define LH 1	// 左高
#define EH 0	// 等高
#define RH -1	// 右高
  ```

举个例子，下图中插入关键字5之前的个结点平衡因子如图所示：

<img src = "https://img-blog.csdnimg.cn/20190914112413984.png"  width = "80%">
 
插入关键字5之后，其父结点即以上的结点平衡因子均发生变化，例如结点6由`EH`变为了`LH`，而结点4由`EH`变为了`RH`;

**值得注意的是**：由于根结点8的平衡因子原本为`LH`，且其左子树增长了，因此可判断AVL树的性质遭到了破坏，需要进行**平衡**操作。

### 2. 非平衡状态

在上面的例子中，结点8的平衡因子为`LH`，而其左孩子结点的平衡因子为`RH`，我们把这种非平衡的状态称为`LR`型。

按照上述方式可以将所有的非平衡状态分为如下四种类型：

<img src = "https://img-blog.csdnimg.cn/20190914114242841.png" width = "100%">

对于这四种类型，在平衡的时候会采取不同的旋转操作。

### 3. AVL旋转

为了使不平衡的AVL树重新达到平衡状态，可以对其作A**VL旋转**操作，旋转分左旋和右旋两种：

其中，**AVL右旋**的示意图如下：

<img src = "https://img-blog.csdnimg.cn/20190914152629522.png" width = "80%">

上图中，对结点`T`进行右旋，而旋转中心可以看做是`T->lchild`，即`T`的左孩子结点。

值得注意的是，AVL旋转操作不会不仅能维护AVL树的平衡性质，还不会破坏二叉搜索书的基本性质，即旋转前后的中序遍历结果相同。

**旋转前**：`a->2->b->4->c->8->d`。**旋转后**：`a->2->b->4->c->8->d`

**AVL左旋**的示意图如下：

<img src = "https://img-blog.csdnimg.cn/20190914153647207.png" width = "80%">

同样的，**AVL**左旋可以看做是绕`T->rchild`进行旋转。

另一点值得注意的是，无论是左旋还是右旋，旋转完成后都需要更新根节点`T`。

**AVL旋转**的C语言代码如下：
```c
void R_Rotate(AVLTree* T) {
	Node* lc = (*T)->lchild;
	(*T)->lchild = lc->rchild;
	lc->rchild = *T; *T = lc;
} // R_Rotate
void L_Rotate(AVLTree* T) {
	Node* rc = (*T)->rchild;
	(*T)->rchild = rc->lchild;
	rc->lchild = *T, * T = rc;
} // L_Rotate
```
### 4. AVL树平衡操作

**AVL树**的平衡操作完全由**AVL旋转**完成，根据**非平衡状态**（`LL、LR、RR、RL`）可分为四种情况，其中`LL`和`RR`仅需要一次旋转即可达到平衡状态，而`LR`和`RL`需两次旋转才能达到平衡状态。

**1. LL型**

**LL型**非平衡状态仅需要一次**右旋**即可达到平衡状态：

<img src = "https://img-blog.csdnimg.cn/20190914162149291.png" width = "80%">

**2. RR型**

**RR型**非平衡状态仅需要一次**左旋**即可达到平衡状态：

<img src = "https://img-blog.csdnimg.cn/20190914162316859.png" width = "80%">

**3. LR型**

**LR型**非平衡状态首先需要将其左子树进行一次**左旋**转换为**LL型**，然后再利用一次**右旋**即可达到平衡状态：

<img src = "https://img-blog.csdnimg.cn/20190914162745782.png" width = "90%">

**4. RL型**

**RL型**非平衡状态首先需要将其右子树进行一次**右旋**转换为**RR型**，然后再利用一次**左旋**即可达到平衡状态：

<img src = "https://img-blog.csdnimg.cn/20190914162807691.png" width = "90%">

**AVL树平衡操作**的C语言代码如下：
```c
void LeftBalance(AVLTree* T) {
	// 对以指针T所指结点为根的二叉树做做平衡旋转处理
	// 算法结束时，指针T指向新的结点
	Node* lc = (*T)->lchild;
	Node* rd = NULL;
	switch (lc->bf)
	{
	case LH:	// LL型：新结点插入在*T的左孩子的左子树上面，作单右旋处理 
		(*T)->bf = lc->bf = EH;
		R_Rotate(T); break;
	case RH:	// LR型：新结点插入在*T的左孩子的右子树上面，作双旋转处理
		rd = lc->rchild;
		switch (rd->bf)
		{
		case LH: (*T)->bf = RH; lc->bf = EH; break;
		case EH: (*T)->bf = lc->bf = EH; break;
		case RH: (*T)->bf = EH; lc->bf = LH; break;
		} // switch(rd->bf)
		rd->bf = EH;
		L_Rotate((*T)->lchild);
		R_Rotate(T);
	} // switch
} // LeftBalance

void RightBalance(AVLTree* T) {
	// 对以指针T所指结点为根的二叉树作右平衡旋转处理
	// 算法结束时，指针T指向新的结点
	Node* rc = (*T)->rchild, *ld;
	switch (rc->bf) {
	case RH:	// RR型：新结点插入在*T的右孩子的右子树上面，作单旋转处理
		(*T)->bf = rc->bf = EH;
		L_Rotate(T); break;
	case LH:	// RL型：新结点插入在*T的右孩子的左子树上面，作双旋转处理
		ld = rc->lchild;
		switch (ld->bf) {
		case RH: (*T)->bf = LH; rc->bf = EH; break;
		case EH: (*T)->bf = rc->bf = EH; break;
		case LH: (*T)->bf = EH; rc->bf = RH; break;
		} // switch(ld->bf)
		ld->bf = EH;
		R_Rotate((*T)->rchild);
		L_Rotate(T);
	} // switch(rc->bf)
} // RightBalance
```

**值得注意的是：**在进行平衡操作的时候还需要根据情况修改各个结点的平衡因子`bf`。

### 5. AVL树的插入

