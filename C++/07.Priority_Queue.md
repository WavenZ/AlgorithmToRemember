## 7. Priority_Queue

### 1. 优先队列简介

**优先队列**是堆的一个典型应用，它和堆一样有最大优先队列和最小优先队列之分。

**优先队列**是一种用来维护由一组元素构成的集合S的数据结构，其中每个元素都有一个相关的值，称为**关键字**(key)。一个**最大优先队列**支持以下几种操作：

 - `Push(S, x)`:把元素x插入集合S中。
 - `front(S)`:返回S中具有最大关键字的元素。
 - `pop(S)`:去掉S中的最大关键字的元素。
 
 优先队列通常是在堆的基础上实现的，下面对堆的基本操作进行回顾：
 
 ### 2. 堆的基本操作
 
  - 1. 维护堆的性质：所有非根节点`i`满足：`A[PARENT(i)] >= A[i]`。
  
  ```
  void max_heapify(int i) {
		unsigned l = 2 * i + 1; // 左孩子
		unsigned r = 2 * i + 2; // 右孩子
		int largest = i;
		if (l < A.size() && A[l] > A[largest])
			largest = l;
		if (r < A.size() && A[r] > A[largest])
			largest = r;
		if (largest != i) { // 最大值
			std::swap(A[i], A[largest]);
			max_heapify(largest); // 迭代维护堆的性质
		}
	}
  ```
  上述操作保证了结点`i`大于其孩子结点。

 - 2. 建堆：建堆的过程实际上就是从下往上维护堆的性质的过程。
 
 ```c
 	void build_max_heapify() {
		for (int i = (A.size() + 1) / 2 + 1; i >= 0; --i) {
			max_heapify(i);
		}
	}
 ```
 其中，`(A.size() + 1) / 2 + 1`为最后一个非叶子结点。
 
 
